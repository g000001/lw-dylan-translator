LW Dylan Translator

--

Directories:

  Share        - code shared between the translator and runtime system
  TransTime    - translator code
  RunTime      - runtime support including Dylan metaobjects
  Lib          - standard libraries
  ParserEngine - shift-reduce parser runtime
  Zimmerman    - zimmerman runtime compatability libraries
  Infix        - infix parser code
  GenericEnv   - some generic support for language listeners and loaders
  Env          - Dylan-specific environment stuff
  Examples     - some example Dylan code

--

General notes:

Lexing is entirely as per CL apart from keywords, which are trapped by
a non-portable trick and returned as lisp keywords, and the # prefixed 
parameter list tokens, which are transformed into corresponding &
prefixed symbols. One further hack to allow the reading of the symbol
|...| is included for the sake of macro system.

Just one big module at this point. There's widespread namespace
polution since, among other things, the Dylan-implemented libraries do
not hide all of their auxiliary functions.

Must load the LW zero-required-args patch to get zero required arg generic
functions!

Things generated by the (method ...) form are standard closures unless
you hint to the translator that you want a real funcallable method by
putting a #next into the parameter list.

No each-subclass slots, and slot types are not checked (CLOS should
but doesn't actually check).

A limited version of the condition system described in the book is provided
and allows conditions to be trapped and also restarts set up for use in
the debugger. Pretty shaky on the whole.

A few forms are available for accessing objects from CL:

  (cl-function {name | (package-name name)}) -> fn
  (cl-value    {name | (package-name name)}) -> fn
  (cl-class    {name | (package-name name)}) -> fn

  (import-cl-functions
    {name  
     | (package-name name)  
     | (name as: dylan-name) 
     | ((package-name name) as: dylan-name)}
    ...)

  (import-cl-values
    {name  
     | (package-name name)  
     | (name as: dylan-name) 
     | ((package-name name) as: dylan-name)}
    ...)

  (import-cl-classes
    {name  
     | (package-name name)  
     | (name as: dylan-name) 
     | ((package-name name) as: dylan-name)}
    ...)

--

The Dylan "environment".

Dylan can be typed directly into a Dylan listener (popped using
dylan:dylan-listen or from the Dylan menu) and files may be
both loaded interpreted and compiled using its "File" menu. Don't
forget that if an error occurs, you are still in the grip of the Dylan
readtable and evaluator.

The editor recognises files with a .dyl extension as being Dylan files and
places them in "Dylan" mode - just a renamed "Lisp" mode. The hooks are defined
which allow you to evaluate and compile definitions, regions and buffers and
also to compile and load files from the File menu. Methods defined via both
DEFINE and DEFINE-METHOD can be traced and untraced from the appropriate menu,
and any Dylan form can be macroexpanded from the expression menu to show
its translation.

Source level debugging now seems to work about as well as it does in LW 
on both interpreted and compiled Dylan. Look for (DEFINE <name>) and
(DEFINE-METHOD <name> (specs)) in backtraces for accessible Dylan frames.

The widespread dynamic rebinding of readtables required to get this to work
sometimes causes undesirable effects - beware!

Don't expect much help from the inspectors or any of the other tools yet.

--
