;;; Copyright (c) 1994, Functional Objects, Inc.
;;; All rights reserved.

;;; Infix-Dylan Phrase Grammar.
 
;;; Incorporates: 
;;;   DIRM 
;;;   Macros specification (draft version 5)
;;;   Unreserved Define Words
;;;   Unreserved Intermediate Words
;;;   Apple Extensions Grammar

(define-parser infix-dylan-parser

  ((top-level command) 
    $1)

  ;; -- Pseudo lexical part

  ((fragment-define-word <fragment-define-word>) 
    $1)
  ((fragment-define-word <fragment-define-and-begin-word>) 
    $1)

  ((fragment-define-bindings-word <fragment-define-bindings-word>)
    $1)
  ((fragment-define-bindings-word <fragment-define-bindings-and-begin-word>)
    $1)

  ((fragment-begin-word <fragment-begin-word>) 
    $1)
  ((fragment-begin-word <fragment-define-and-begin-word>) 
    $1)
  ((fragment-begin-word <fragment-define-bindings-and-begin-word>) 
    $1)

  ;; -- Program structure

  ((marker-clause "Program structure"))

  ((dylan-program opt-body)
    $1)

  ((body constituents opt-<statement-sep>)
    (body-fragment constituents: $1))

  ((constituents constituent <statement-sep> ...))

  ((constituent defining-form)     
    $1)
  ((constituent local-declaration)
    $1)
  ((constituent expression)
    $1)

  ;; -- New property lists

  ((marker-clause "Property lists" :same-page t))

  ((opt-property-list)
    (property-list-fragment items: '()))
  ((opt-property-list property-list)
    $1)

  ((property-list the-property-list)
    (property-list-fragment items: $1))

  ((opt-the-property-list)
    '())
  ((opt-the-property-list the-property-list)
    $1)

  ((the-property-list property ...)
    base: $1
    rec:  `(,@$1 ,@$2))

  ((property <var-sep> <keyword> value)
    `(,$2 ,$3))
  
  ((value expression)
    $1)
  ((value <lcbracket> opt-property-set <rcbracket>)
    $2)

  ((opt-property-set)
    '())
  ((opt-property-set property-set)
    $1)

  ((property-set property-set-member <var-sep> ...))

  ((property-set-member property-set-item)
    $1)
  ((property-set-member property-set-item <implies> property-set-item)
    `(,$1 => ,$3))

;;  ((property-set-item <symbol>)
;;    $1)
  ((property-set-item word)
    $1)
  ((property-set-item constant)
    $1)

  ((property-list-no-comma <keyword> value opt-the-property-list)
    (property-list-fragment items: `(,$1 ,$2 ,@$3)))

  ;; -- Defining forms

  ((marker-clause "Defining forms"))

  ((defining-form 
       :define opt-modifiers method-defining-word
         method-definition)
    `(,(infix-defining-macro-name $3 modifiers: $2) ,$2 ,@$4))
  ((defining-form
       :define opt-modifiers generic-function-defining-word
         generic-function-definition)
    `(,(infix-defining-macro-name $3 modifiers: $2) ,$2 ,@$4))
  ((defining-form
       :define opt-modifiers <defining-word> definition)
    `(,(infix-defining-macro-name $3 modifiers: $2) ,$2 ,@$4))
  ((defining-form
       :define opt-modifiers <defining-word> bindings)
    `(,(infix-defining-macro-name $3 modifiers: $2) ,$2
         ,@(first $4) ,(second $4)))

  ((opt-modifiers)
    '())
  ((opt-modifiers modifiers)
    $1)

  ((modifiers the-modifiers)
    (modifiers-fragment items: $1))

  ((the-modifiers modifier ...))

  ((modifier <symbol>)
    $1)

  ((method-defining-word :method)
    'method)
  ((method-defining-word <method-defining-word>)
    $1)

  ((generic-function-defining-word :generic)
    'generic)
  ((generic-function-defining-word <generic-function-defining-word>)
    $1)

  ((method-definition
        variable-name method-body :end opt-method opt-variable-name)
     `(,$1 ,@$2))

  ((generic-function-definition
        variable-name generic-function-body opt-property-list)
     `(,$1 ,@$2 ,@$3))

  ((definition 
        variable-name opt-expression-list 
          opt-item-list
        end-definition)
     `(,$1 ,@(if $2 `(,$2) '()) ,@$3))

  ((end-definition :end ))
  ((end-definition :end variable-name))
  ((end-definition :end <defining-word> variable-name))

  ((opt-<defining-word>))
  ((opt-<defining-word> <defining-word>))

  ((opt-expression-list)
    #f)
  ((opt-expression-list expression-list)
    $1)

  ((expression-list <lbracket> opt-expressions <rbracket>)
    $2)

  ((opt-expressions)
    `())
  ((opt-expressions expressions)
    $1)

  ((opt-item-list)
    '())
  ((opt-item-list item-list)
    $1)

  ((item-list items opt-<statement-sep>)
    $1)

  ((items item <statement-sep> ...))

  ((item item-modifiers-and-word item-names opt-property-list)
    `(,@$1 ,@$2 ,@$3))
  ((item item-modifiers-and-word item-names type-designator opt-property-list)
    `(,@$1 (,@$2 ,$3) ,@$4))
  ((item item-modifiers-and-word item-names default opt-property-list)
    `(,@$1 ((,@$2) ,@$3) ,@$4))
  ((item item-modifiers-and-word item-names type-designator default opt-property-list)
    `(,@$1 ((,@$2 ,$3) ,@$4) ,@$5))

  ((item-modifiers-and-word item-modifier ...))

  ((item-modifier <symbol>)
    $1)
  ((item-modifier <defining-word>)
    $1)

  ((item-names item-name <var-sep> ...))

  ((item-name variable-name)
    $1)
  ((item-name <keyword>)
    $1)

  ;; -- Sealing declarations.

  ((defining-form
      seal-word opt-modifiers :generic
        variable-name <lbracket> opt-expressions <rbracket>)
    `(seal-generic ,$2 ,$4 ,$6))

  ((seal-word <seal-word>)
    $1)

  ;; -- Local declarations.

  ((marker-clause "Local declarations"))

  ((local-declaration :let bindings)
    (make-bind-marker :bindings $2))
  ((local-declaration 
    :let :handler condition <binds> handler)
    (make-bind-handler-marker :exception $3 :expression $5))
  ((local-declaration :local local-methods)
    (make-local-marker :methods $2))
  ((local-declaration <fragment-local-declaration-word> fragment-constituent)
    (make-local-macro-marker :name $1 :fragment $2))

  ((condition type)
    `(,$1))
  ((condition <lbracket> type property-list <rbracket>)
    `(,$2 ,@$3))

  ((handler expression)
    $1)

  ((local-methods local-method <var-sep> ...))

  ((local-method opt-method named-method) 
    $2)

  ((bindings variables <binds> expression)
    (list $1 $3))
  ((bindings <lbracket> variables <rbracket> <binds> expression)
    (list $2 $5))
  
  ((variables :&rest variable-name)
    `(#rest ,$2))
  ((variables variable)
    `(,$1))
  ((variables variable <var-sep> variables)
    `(,$1 ,@$3))

  ((variable typed-variable)
    $1)
  ((variable untyped-variable)
    $1)

  ((untyped-variable variable-name)
    $1)

  ((typed-variable variable-name type-designator)
    `(,$1 ,$2))

  ((type-designator <var-type-sep> type)
    $2)

  ((type operand)
    $1)

  ((opt-variable-name) 
    #f)
  ((opt-variable-name variable-name) 
    $1)

  ((variable-name the-variable-name)
    (name-fragment name: $1))

  ((the-variable-name <symbol>)
    $1)
  ((the-variable-name <defining-word>)
    $1)
  ((the-variable-name <method-defining-word>) ;; Can't be "method" itself
    $1)
  ((the-variable-name generic-function-defining-word)
    $1)
  ((the-variable-name <ellipsis>)
    $1)

  ((opt-method))
  ((opt-method :method))
  ((opt-method fragment-begin-word))

  ;; -- Expressions

  ((marker-clause "Expressions"))

  ((expressions expression <var-sep> ...))

  ((expression binary-operand-series)
    (expression-fragment series: $1))

  ((binary-operand-series binary-operand binary-operator ...)
    rec: `(,@$1 ,$2 ,$3))

  ;; Forced deviation 

  ((keyless-expression keyless-binary-operand-series)
    (expression-fragment series: $1))
   
  ((keyless-binary-operand-series
        keyless-binary-operand)
    `(,$1))
  ((keyless-binary-operand-series
        keyless-binary-operand binary-operator binary-operand-series)
    `(,$1 ,$2 ,@$3))

;; ((keyless-binary-operand-series keyless-binary-operand binary-operator ...)
;;    rec: `(,@$1 ,$2 ,$3))

  ((binary-operand <keyword>)
    $1)
  ((binary-operand keyless-binary-operand)
    $1)

  ((keyless-binary-operand operand)
    $1)
  ((keyless-binary-operand unary-operator operand)
    `(,$1 ,$2))
;;  ((keyless-binary-operand location-list)
;;    $1)

  ((location-list <lbracket> expression <var-sep> expressions <rbracket>)
    `(locations: ,$2 ,@$4))

  ((unary-operator <unary-operator>)
    $1)
  ((unary-operator <minus>)
    'negative)
  ((unary-operator <not>)
    '~)

  ((binary-operator <binary-operator>) 
    (convert-binop $1))
  ((binary-operator <minus>)
    '-)
  ((binary-operator <binds>)
    (convert-binop '=))
  ((binary-operator <var-singleton-sep>)
    '==)
  ((binary-operator <becomes>)
    'set!)
;  ((binary-operator <var-type-sep>)
;    'check-type)

  ((operand operand <lbracket> opt-arguments <rbracket>)
    (call-fragment function: $1 arguments: $3))
  ((operand operand <lsbracket> arguments <rsbracket>)
    (if (= (size $3) 1)
      `(element ,$1 ,@$3)
      `(aref ,$1 ,@$3)))
  ((operand operand <dot> variable-name)
    `(,(make-getter-name $3) ,$1))
  ((operand function-macro-call)
    $1)
  ((operand leaf)
    $1)

  ((arguments argument <var-sep> ...)
    base: $1
    rec:  `(,@$1 ,@$3))

  ((function-macro-call 
     <fragment-function-word> <lbracket> opt-fragment <rbracket>)
     (fragment-function-call-fragment word: $1 fragment: $3))

  ;; Forced deviation 

  ((argument keyless-expression)
    `(,$1))
  ((argument <keyword>)
    `(,$1))
  ((argument <keyword> expression)
    `(,$1 ,$2))

  ((leaf literal) 
    (select $1 instance?
      ((<string> <integer> <boolean>) $1)
      (else: 
	(if (keyword? $1) $1 `',$1))))
  ((leaf variable-name)
    $1)
  ((leaf <lbracket> expression <rbracket>)
    $2)
  ((leaf anonymous-method) 
    $1)
  ((leaf statement) 
    $1)

  ((literal <literal>) 
    $1)
  ((literal <string> ___)
    base: $1
    rec:  (concatenate $1 $2))
  ((literal :true)
    #t)
  ((literal :false)
    #f)
  ((literal <list-open> constants <dot> constant <rbracket>)
    (concatenate-atom $2 $4))
  ((literal <list-open> opt-constants <rbracket>)
    $2)
  ((literal <vector-open> opt-constants <rsbracket>)
    (as <vector> $2))

  ((constants constant <var-sep> ...))

  ((constant literal) 
    $1)
  ((constant <keyword>)
    $1)

  ;; -- Statements

  ((marker-clause "Statements"))

  ((statement begin-clause opt-clause-body end-clause)
    (clauses-statement-fragment
       word:         (word $1)
       begin-clause: $1
       body:         (first $2)
       clause-body:  (second $2)))

  ((statement begin-clause case-body end-clause)
    (cases-statement-fragment
      word:         (word $1)
      begin-clause: $1
      case-body:    $2))

  ((begin-clause 
      <details-begin-word> 
        opt-variable-name detail-info)
    (details-begin-clause-fragment
       word:          $1
       variable-name: $2
       detail-info:   $3))
  ((begin-clause 
      <expr-begin-word> 
        opt-variable-name <lbracket> expression opt-detail-clauses <rbracket>)
    (expr-begin-clause-fragment
       word:           $1
       variable-name:  $2
       expression:     $4
       detail-clauses: $5))
  ((begin-clause <simple-begin-word>)
     (simple-begin-clause-fragment word: $1))

  ((opt-clause-body)
    `(,(body-fragment constituents: '())
      ,(clause-body-fragment clauses: '())))
  ((opt-clause-body clause-body)
    $1)

  ((clause-body body opt-intermediate-clauses)
    `(,$1 
      ,(clause-body-fragment clauses: $2)))
  ((clause-body intermediate-clauses)
    `(,(body-fragment constituents: '())
      ,(clause-body-fragment clauses: $1)))

  ((opt-intermediate-clauses)
    '())
  ((opt-intermediate-clauses intermediate-clauses)
    $1)

  ((intermediate-clauses the-intermediate-clauses)
    (intermediate-clauses-fragment clauses: $1))

  ((the-intermediate-clauses
      intermediate-clause opt-body)
    `(,(clause-with-body-fragment clause: $1 body: $2)))
  ((the-intermediate-clauses 
      intermediate-clauses intermediate-clause opt-body)
    `(,@$1 ,(clause-with-body-fragment clause: $2 body: $3)))

  ((intermediate-clause 
       <details-intermediate-word> 
         opt-variable-name detail-info
	   opt-<statement-sep>)
    (details-intermediate-clause-fragment
       word:          $1
       variable-name: $2
       detail-info:   $3))
  ((intermediate-clause
       <expr-intermediate-word> 
         opt-variable-name 
           <lbracket> expression opt-detail-clauses <rbracket>
	     opt-<statement-sep>)
    (expr-intermediate-clause-fragment
       word:           $1
       variable-name:  $2
       expression:     $4
       detail-clauses: $5))
  ((intermediate-clause
       <simple-intermediate-word>)
    (simple-intermediate-clause-fragment
      word: $1))

  ((end-clause :end opt-begin-word))

  ((begin-word <details-begin-word>)
    $1)
  ((begin-word <expr-begin-word>)
    $1)
  ((begin-word <simple-begin-word>)
    $1)

  ((case-body the-case-body)
    (case-body-fragment cases: $1))

  ((opt-case-body)
    (case-body-fragment cases: '()))
  ((opt-case-body case-body)
    $1)

  ((the-case-body intermediate-case intermediate-case-tail)
    (bind ((case/case-label $1)
           (case-body/cases $2))
      `(,(first case/case-label)
        (,(second case/case-label) ,(first case-body/cases))
        ,@(second case-body/cases))))
  ((the-case-body final-case)
    `(,$1))

  ((intermediate-case case-label <statement-sep> case-label)
    `((,$1 (begin)) ,$3))
  ((intermediate-case case-label constituents <statement-sep> case-label)
    `((,$1 ,(rewrite-parsed-body $2)) ,$4))

  ((intermediate-case-tail final-case-body)
    `(,$1 ()))
  ((intermediate-case-tail <statement-sep> case-body)
    `((begin) ,$2))
  ((intermediate-case-tail constituents <statement-sep> case-body)
    `(,(rewrite-parsed-body $1) ,$3))

  ((final-case case-label final-case-body)
    `(,$1 ,$2))

  ((final-case-body opt-body)
     $1)
  ((final-case-body <statement-sep>)
    `(begin))

  ((case-label
    expressions <implies>)
    $1)
  ((case-label 
    <lbracket> expression <var-sep> expressions <rbracket> <implies>)
    `(,$2 ,@$4))
  ((case-label 
    :otherwise opt-<implies>)
    'otherwise)

  ((detail-info <lbracket> opt-detail-list <rbracket>)
    (detail-info-fragment detail-list: $2))

  ((opt-detail-list)
    '())
  ((opt-detail-list detail-list)
    $1)

  ((detail-list details opt-property-list)
    (detail-list-with-properties-fragment details: $1 property-list: $2))
  ((detail-list property-list-no-comma)
    (detail-list-with-properties-fragment details: '() property-list: $1))
  ((detail-list details <var-sep> <expr-begin-word> expression)
    (detail-list-with-begin-word-fragment 
      details: $1 word: $3 expression: $4))

  ((details detail)
    `(,$1))
  ((details details <var-sep> detail)
    `(,@$1 ,$3))

  ((detail variable opt-detail-clauses)
    (detail-fragment 
      variables: $1
      first-detail-clause: #f
      detail-clauses: $2))
  ((detail variable <binds> expression opt-detail-clauses)
    (detail-fragment 
       variables:      $1
       first-detail-clause: (detail-clause-fragment 
                             symbol:     (name-fragment name: '=)
                             expression: $3)
       detail-clauses: $4))
  ((detail <lbracket> variables <rbracket> opt-detail-clauses)
    (detail-fragment 
      variables: $2
      first-detail-clause: #f
      detail-clauses: $4))
  ((detail <lbracket> variables <rbracket> <binds>
	 expression opt-detail-clauses)
    (detail-fragment 
       variables:      $2
       first-detail-clause: (detail-clause-fragment 
                             symbol:     (name-fragment name: '=)
                             expression: $5)
       detail-clauses: $6))

  ((opt-detail-clauses)
    (detail-clauses-fragment clauses: '()))
  ((opt-detail-clauses detail-clauses)
    $1)

  ((detail-clauses the-detail-clauses)
    (detail-clauses-fragment clauses: $1))

  ((the-detail-clauses detail-clause)
    `(,$1))
  ((the-detail-clauses the-detail-clauses detail-clause)
    `(,@$1 ,$2))

  ((detail-clause detail-clause-word expression)
    (detail-clause-fragment 
      symbol:     (name-fragment name: $1)
      expression: $2))

  ((detail-clause-word <symbol>)
     $1)

  ;; -- Methods

  ((marker-clause "Methods and generic functions"))

  ((anonymous-method :method method-body :end opt-method)
    `(method ,@$2))

  ((named-method variable-name method-body :end opt-method opt-variable-name)
    `(,$1 ,@$2))

  ((method-body
       <lbracket> opt-parameters <rbracket> 
         opt-method-return-type opt-body)
    `((,@$2 #values ,@$4) ,$5))

  ((generic-function-body
       <lbracket> opt-parameters <rbracket>
         opt-generic-function-return-type)
    `((,@$2 #values ,@$4)))

  ((opt-parameters)
    '())
  ((opt-parameters parameters)
    $1)

  ((parameters positional-parameters)
    $1)
  ((parameters positional-parameters <var-sep> next-parameters)
    `(,@$1 ,@$3))
  ((parameters next-parameters)
    $1)

  ((positional-parameters positional-parameter)
    `(,$1))
  ((positional-parameters 
       positional-parameters <var-sep> positional-parameter)
    `(,@$1 ,$3))

  ((positional-parameter variable-name)
    `(,$1 <object>))
  ((positional-parameter variable-name <var-type-sep> expression)
    `(,$1 ,$3))
  ((positional-parameter variable-name <var-singleton-sep> expression)
    `(,$1 (singleton ,$3)))

  ((next-parameters next-parameter)
    $1)
  ((next-parameters next-parameter <var-sep> rest-parameters)
    `(,@$1 ,@$3))
  ((next-parameters rest-parameters)
    $1)

  ((next-parameter :&next variable-name)
    `(#next ,$2))

  ((rest-parameters rest-parameter)
    $1)
  ((rest-parameters rest-parameter <var-sep> keyword-parameters)
    `(,@$1 ,@$3))
  ((rest-parameters keyword-parameters)
    $1)

  ;; Extension?

  ((rest-parameter :&rest variable)
    `(#rest ,$2))

  ((keyword-parameters :&key)
    '(#key))
  ((keyword-parameters :&key <var-sep> :&all-keys)
    '(#key #all-keys))
  ((keyword-parameters :&all-keys)
    '(#all-keys))
  ((keyword-parameters :&key keyword-parameter-list)
    `(#key ,@$2))
  ((keyword-parameters :&key keyword-parameter-list <var-sep> :&all-keys)
    `(#key ,@$2 &all-keys))

  ((keyword-parameter-list keyword-parameter)
    `(,$1))
  ((keyword-parameter-list keyword-parameter-list <var-sep> keyword-parameter)
    `(,@$1 ,$3))

  ((keyword-parameter typed-keyword-variable opt-default)
    (if $2 `(,@$1 ,@$2) $1))
  ((keyword-parameter untyped-keyword-variable opt-default)
    (if $2 `(,@$1 ,@$2) $1))

  ((keyword-variable typed-keyword-variable)
    $1)
  ((keyword-variable untyped-keyword-variable)
    $1)

  ((typed-keyword-variable 
     <keyword> variable-name <var-type-sep> type)
    `(,$1 ,$2))
  ((typed-keyword-variable 
     <keyword> <var-type-sep> type)
    `(,$1 ,(as <symbol> (as <string> $1))))
  ((typed-keyword-variable 
     variable-name <var-type-sep> type)
    `(,$1))

  ((untyped-keyword-variable <keyword> variable-name)
    `(,$1 ,$2))
  ((untyped-keyword-variable <keyword>)
    `(,$1 ,(as <symbol> (as <string> $1))))
  ((untyped-keyword-variable variable-name)
    `(,$1))

  ((opt-default)
    `())
  ((opt-default default)
    $1)

  ((default <binds> expression)
    `(,$2))

  ((opt-method-return-type)
    '(#rest x))
  ((opt-method-return-type method-return-type)
    $1)

  ;; Replace variable with parameter in return type lists
  ;; Also fix the fact the #rest isn't allowed

  ((method-return-type <statement-sep>)
    '())
  ((method-return-type <implies> positional-parameter <statement-sep>) 
    `(,$2))
  #|
  ((method-return-type <var-type-sep> type <statement-sep>) 
    `((_ ,$2)))
  |#
  ((method-return-type 
      <implies> 
        <lbracket> opt-return-type-list <rbracket> opt-<statement-sep>)
    $3)

  ((opt-generic-function-return-type)
    '(#rest x))
  ((opt-generic-function-return-type generic-function-return-type)
    $1)

  ((generic-function-return-type <implies> positional-parameter)
    `(,$2))
  ((generic-function-return-type 
      <implies> 
        <lbracket> opt-return-type-list <rbracket>)
    $3)


  ((opt-return-type-list) '())
  ((opt-return-type-list return-type-list) $1)

  ((return-type-list parameters) $1)

  ;; -- Boring utilities

  ((opt-keyword <keyword>) `(,$1))
  ((opt-keyword) '())

  ((opt-body body) $1)
  ((opt-body)      `(begin))

  ((opt-gf-parameters)               '())
  ((opt-gf-parameters gf-parameters) $1)

  ((opt-arguments arguments) $1)
  ((opt-arguments) '())

  ((opt-<statement-sep>) '())
  ((opt-<statement-sep> <statement-sep>) '())

  ((opt-bare-literals) '())
  ((opt-bare-literals bare-literals) $1)

  ;; Optionals.

  ((opt-<implies>)
    #f)
  ((opt-<implies> <implies>)
    $1)

  ((opt-unary-operator)
    #f)
  ((opt-unary-operator unary-operator)
    $1)

  ((opt-constants)
    '())
  ((opt-constants constants)
    $1)

  ((opt-exit-symbol variable-name) 
    $1)
  ((opt-exit-symbol) #f)

  ((opt-block-epilog
     opt-exception-clauses :cleanup body opt-exception-clauses)
       (pair (concatenate $1 $4) $3))
  ((opt-block-epilog opt-exception-clauses)
    (pair $1 #f))

  ((opt-exception-clauses exception-clauses)
    $1)
  ((opt-exception-clauses)
    '())

  ((opt-constituents)
    '())
  ((opt-constituents constituents)
    $1)

  ((opt-begin-word)
    #f)
  ((opt-begin-word begin-word)
    $1)

  ;; -- Deep syntax of program fragments

  ((marker-clause "Deep syntax"))

  ;; -- Trial macros

  ((begin-word fragment-begin-word)
    $1)

  ((statement fragment-begin-word opt-fragment end-clause)
     (fragment-statement-fragment word: $1 fragment: $2))

  ((the-variable-name <fragment-define-word>)
    $1)
  ((the-variable-name <fragment-define-bindings-word>)
    $1)

  ;; The following because if the word's a statement as well, it's not
  ;; covered by variable-name above.
  ((end-definition :end <fragment-define-and-begin-word>))
  ((end-definition :end fragment-define-word variable-name))

  ((defining-form 
       :define opt-modifiers fragment-define-word opt-fragment 
       end-definition)
     (fragment-defining-form-fragment 
       word: $3 modifiers: $2 fragment: $4))

  ((defining-form 
       :define opt-modifiers fragment-define-bindings-word
	 opt-fragment-constituent)
     (fragment-defining-form-fragment 
       word: $3 modifiers: $2 fragment: (sequence-fragment fragments: $4)))

  ((opt-fragment) 
    (sequence-fragment fragments: '()))
  ((opt-fragment fragment) 
    $1)

  ;; Note: this fragment grammar is not quite accurate since it disallows
  ;; [comma | semi]+ sequences - they must have something inbetween them.
  ;; Easily fixed by moving the opt-s around a bit.

  ;; A generic program fragment
  ((fragment fragment-constituents) 
    (sequence-fragment fragments: $1))

  ((opt-fragment-constituents) '())
  ((opt-fragment-constituents fragment-constituents) $1)

  ;; Semicolon separated things
  ((fragment-constituents fragment-constituent) $1)
  ((fragment-constituents 
      fragment-constituent <statement-sep> opt-fragment-constituents)
    `(,@$1 ,*semicolon* ,@$3))

  ((opt-fragment-constituent) '())
  ((opt-fragment-constituent fragment-constituent) $1)

  ((fragment-constituent fragment-list) 
    $1)
  ((fragment-constituent defining-form) 
    `(,(parsed-fragment 
         token-class: parsed-defining-form:
         token-value: $1)))
  ((fragment-constituent fragment-list defining-form) 
    `(,@$1 ,(parsed-fragment 
              token-class: parsed-defining-form:
              token-value: $2)))
  ((fragment-constituent local-declaration) 
    `(,(parsed-fragment 
         token-class: parsed-local-declaration:
         token-value: $1)))
  ((fragment-constituent fragment-list local-declaration) 
    `(,@$1 ,(parsed-fragment 
              token-class: parsed-local-declaration:
              token-value: $2)))

  ;; Comma separated things
  ((fragment-list fragment-sequence)
     $1)
  ((fragment-list opt-fragment-sequence <var-sep> opt-fragment-list)
    `(,@$1 ,*comma* ,@$3))

  ((opt-fragment-list) '())
  ((opt-fragment-list fragment-list) $1)

  #|
  ((fragment-list fragment-sequence <var-sep> ...)
    base: $1
    rec:  `(,@$1 ,*comma* ,@$3))
  |#

  ((opt-fragment-sequence) '())
  ((opt-fragment-sequence fragment-sequence) $1)

  ;; Juxtaposed things
  ((fragment-sequence statement-or-method opt-non-statement-etc)
    `(,(parsed-fragment 
          token-class: parsed-statement:
          token-value: $1)
       ,@$2))
  ((fragment-sequence non-statement-etc) 
    $1)

  ((statement-or-method statement)
     $1)
  ((statement-or-method anonymous-method)
     $1)

  ((opt-non-statement-etc) '())
  ((opt-non-statement-etc non-statement-etc) $1)

  ((non-statement-etc simple-fragment opt-fragment-sequence)
    `(,$1 ,@$2))
  ((non-statement-etc implies-fragment opt-fragment-sequence)
    `(,$1 ,@$2))

  ;; Anything other than a defining-form, local-declaration, or statement
  ((simple-fragment modified-constant) $1)
  ((simple-fragment word-fragment) $1)
  ((simple-fragment <lbracket> opt-fragment-constituents <rbracket>)
    (bracketed-fragment fragments: $2))
  ((simple-fragment <lsbracket> opt-fragment-constituents <rsbracket>)
    (sbracketed-fragment fragments: $2))
  ((simple-fragment <lcbracket> opt-fragment-constituents <rcbracket>)
    (cbracketed-fragment fragments: $2))
  ((simple-fragment <lcbracket> opt-fragment-constituents :end <rcbracket>)
    (cbracketed-fragment fragments: $2))
  ((simple-fragment function-macro-call)
    (parsed-fragment 
      token-class: parsed-expression:
      token-value: $1))
  ((simple-fragment <dot>)
    (literal-fragment
       object: (as <symbol> ".") token-class: '<dot> token-value: $1))
  ((simple-fragment :&next) 
    (literal-fragment
       object: '#next token-class: ':&next token-value: $1))
  ((simple-fragment :&rest) 
    (literal-fragment
       object: '#rest token-class: ':&rest token-value: $1))
  ((simple-fragment :&key) 
    (literal-fragment
       object: '#key token-class: ':&key token-value: $1))
  ((simple-fragment :&all-keys) 
    (literal-fragment
       object: '#all-keys token-class: ':&all-keys token-value: $1))
  ((simple-fragment :otherwise) 
    (literal-fragment
       object: 'otherwise token-class: ':otherwise token-value: $1))
  ((simple-fragment <var-type-sep>)
    (literal-fragment
       object: '|::| token-class: '<var-type-sep> token-value: $1))
  ((simple-fragment <ellipsis>)
    (literal-fragment
       object: '|...| token-class: '<ellipsis> token-value: $1))
  ((simple-fragment <query>)
    (literal-fragment
       object: '|?| token-class: '<query> token-value: $1))
  ((simple-fragment <query-query>)
    (literal-fragment
       object: '|??| token-class: '<query-query> token-value: $1))
  ((simple-fragment <query-equal>)
    (literal-fragment
       object: '|?=| token-class: '<query-equal> token-value: $1))

  ((implies-fragment <implies>) 
    (literal-fragment
       object: '=> token-class: '<implies> token-value: $1))

  ;; A quirk necessary due to string concatenation.
  ((modified-constant <literal>) 
    (literal-fragment
      object: $1 token-class: '<literal> token-value: $1))
  ((modified-constant <string>) 
    (literal-fragment
      object: $1 token-class: '<string> token-value: $1))
  ((modified-constant <keyword>) 
    (literal-fragment
      object: $1 token-class: '<keyword> token-value: $1))
  ((modified-constant :true) 
    (literal-fragment
      object: $1 token-class: :true token-value: $1))
  ((modified-constant :false) 
    (literal-fragment
      object: $1 token-class: :false token-value: $1))
  ((modified-constant <list-open> constants <dot> constant <rbracket>)
    (parsed-fragment 
      token-class: :parsed-literal token-value: `(,@$2 . ,$4)))
  ((modified-constant <list-open> opt-constants <rbracket>)
    (parsed-fragment 
      token-class: :parsed-literal token-value: $2))
  ((modified-constant <vector-open> opt-constants <rsbracket>)
    (parsed-fragment 
      token-class: :parsed-literal token-value: (as <vector> $2)))

  ((word-fragment <symbol>) 
    (literal-fragment
       object: $1 token-class: '<symbol> token-value: $1))
  ((word-fragment <defining-word>) 
    (literal-fragment
       object: $1 token-class: '<defining-word> token-value: $1))
  ((word-fragment <fragment-define-word>) 
    (literal-fragment
       object: $1 token-class: '<fragment-define-word> token-value: $1))
  ((word-fragment <fragment-define-bindings-word>) 
    (literal-fragment
       object: $1 
       token-class: '<fragment-define-bindings-word>
       token-value: $1))
  ((word-fragment <binary-operator>) 
    (literal-fragment
       object: $1 token-class: '<binary-operator> token-value: $1))
  ((word-fragment <minus>) 
    (literal-fragment
       object: '- token-class: '<minus> token-value: $1))
  ((word-fragment <binds>) 
    (literal-fragment
       object: '= token-class: '<binds> token-value: $1))
  ((word-fragment <var-singleton-sep>) 
    (literal-fragment
       object: '== token-class: '<var-singleton-sep> token-value: $1))
  ((word-fragment <becomes>) 
    (literal-fragment
       object: '|:=| token-class: '<becomes> token-value: $1))
  ((word-fragment <not>) 
    (literal-fragment
       object: '~ token-class: '<not> token-value: $1))

  ;; Extra words we have because of the old macro system.

  #|
  ((word-fragment <details-intermediate-word>)
    (literal-fragment
       object: $1 token-class: '<details-intermediate-word> token-value: $1))
  ((word-fragment <expr-intermediate-word>)
    (literal-fragment
       object: $1 token-class: '<expr-intermediate-word> token-value: $1))
  ((word-fragment <simple-intermediate-word>)
    (literal-fragment
       object: $1 token-class: '<simple-intermediate-word> token-value: $1))
  |#

  ;; Need to accept parsed stuff too for macro->macro transformations
  ;; to work correctly.

  ((simple-fragment :parsed-name)
    (parsed-fragment
       token-class: parsed-name: token-value: $1))
  ((simple-fragment :parsed-variable)
    (parsed-fragment
       token-class: parsed-variable: token-value: $1))
  ((simple-fragment :parsed-expression)
    (parsed-fragment
       token-class: parsed-expression: token-value: $1))
  ((simple-fragment :parsed-body)
    (parsed-fragment
       token-class: parsed-body: token-value: $1))
  ((simple-fragment :parsed-case-body)
    (parsed-fragment
       token-class: parsed-case-body: token-value: $1))
  ((simple-fragment :parsed-literal)
    (parsed-fragment
       token-class: parsed-literal: token-value: $1))

  #|

  ;; Much hair to support case-body fragments in a reasonably generic
  ;; way.

  ((opt-case-body-fragment)
    '())
  ((opt-case-body-fragment case-body-fragment)
    $1)

  ((case-body-fragment
     intermediate-case-fragment intermediate-case-tail-fragment)
    `(,@$1 ,@$2))
  ((case-body-fragment
     final-case-fragment)
    $1)

  ((intermediate-case-fragment 
     case-label-fragment <statement-sep>
     case-label-fragment)
    `(,@$1 ,*semicolon* ,@$3))
  ((intermediate-case-fragment
     case-label-fragment case-constituents-fragment <statement-sep> 
     case-label-fragment)
    `(,@$1 ,(grouped-fragment fragments: $2) ,*semicolon* ,@$4))

  ((intermediate-case-tail-fragment 
     final-case-body-fragment)
    $1)
  ((intermediate-case-tail-fragment 
     <statement-sep> case-body-fragment)
    `(,*semicolon* ,@$2))
  ((intermediate-case-tail-fragment 
     case-constituents-fragment <statement-sep> case-body-fragment)
    `(,(grouped-fragment fragments: $1) ,*semicolon* ,@$3))

  ((final-case-fragment
      case-label-fragment final-case-body-fragment)
    `(,@$1 ,@$2))

  ((final-case-body-fragment
      case-constituents-fragment)
    `(,(grouped-fragment fragments: $1)))

  ((case-label-fragment no-implies-fragment-list <implies>)
    `(,@$1 ,*implies*))

  ((case-constituents-fragment 
      no-implies-fragment-constituent <statement-sep> ...)
    base: $1
    rec:  `(,@$1 ,*semicolon* ,@$3))

  ((no-implies-fragment-constituent no-implies-fragment-list) 
    $1)
  ((no-implies-fragment-constituent defining-form) 
    `(,(parsed-fragment 
         token-class: parsed-defining-form:
         token-value: $1)))
  ((no-implies-fragment-constituent no-implies-fragment-list defining-form) 
    `(,@$1 ,(parsed-fragment 
              token-class: parsed-defining-form:
              token-value: $2)))
  ((no-implies-fragment-constituent local-declaration) 
    `(,(parsed-fragment 
         token-class: parsed-local-declaration:
         token-value: $1)))
  ((no-implies-fragment-constituent no-implies-fragment-list local-declaration) 
    `(,@$1 ,(parsed-fragment 
              token-class: parsed-local-declaration:
              token-value: $2)))

  ;; Comma separated things
  ((no-implies-fragment-list no-implies-fragment-sequence <var-sep> ...)
    base: $1
    rec:  `(,@$1 ,*comma* ,@$3))

  ((opt-no-implies-fragment-sequence) '())
  ((opt-no-implies-fragment-sequence no-implies-fragment-sequence) $1)

  ;; Juxtaposed things
  ((no-implies-fragment-sequence
      statement-or-method opt-no-implies-non-statement-etc)
    `(,(parsed-fragment 
          token-class: parsed-statement:
          token-value: $1)
       ,@$2))
  ((no-implies-fragment-sequence no-implies-non-statement-etc) 
    $1)

  ((opt-no-implies-non-statement-etc) '())
  ((opt-no-implies-non-statement-etc no-implies-non-statement-etc) $1)

  ((no-implies-non-statement-etc 
      simple-fragment opt-no-implies-fragment-sequence)
    `(,$1 ,@$2))

  |#

  ;; -- Macros

  ((marker-clause "Macro definitions"))

  ((defining-form
       :define opt-modifiers macro-defining-word macro-definition)
    `(,(infix-defining-macro-name $3 modifiers: $2) ,$2
         ,@$4))

  ((macro-defining-word :macro)
    'macro)
  ((macro-defining-word <macro-defining-word>)
    $1)

  ((opt-detail-info)
    '())
  ((opt-detail-info detail-info)
    $1)

  ((macro-definition 
        word opt-detail-info main-rule-set opt-aux-rule-sets 
      :end opt-macro opt-non-intermediate-word)
    (if (empty? $2)
      `(,$1 ,$3 ,$4)
      `((,$1 ,@$2) ,$3 ,$4)))

  ((statement
       :macro-case <lbracket> expression <rbracket>
         aux-rules
         opt-aux-rule-sets
       :end opt-macro-case)
    `(infix-macro-case ,$3 ,$5 ,$6))

  ((opt-macro-case))
  ((opt-macro-case :macro-case))

  ((main-rule-set statement-rule ___))
  ((main-rule-set define-rule ___))
  ;; ((main-rule-set function-rule ___))
  ((main-rule-set function-or-local-declaration-rule ___))

  ((statement-rule
     <lcbracket> word opt-pattern :end <rcbracket>
       <implies> rule-rhs opt-<statement-sep>)
    (statement-rule
      name:    $2
      pattern: (statement-rule-pattern name: $2 pattern: $3)
      template: $7))

  ((define-rule
     <lcbracket> :define pattern :end <rcbracket>
       <implies> rule-rhs opt-<statement-sep>)
    (define-rule
      name:    #f
      pattern:  (define-rule-pattern 
                  name: #f modifiers-pattern: #f pattern: $3)
      template: $7))

  ((define-rule
     <lcbracket> :define pattern <rcbracket>
       <implies> rule-rhs opt-<statement-sep>)
    (define-bindings-rule
      name:    #f
      pattern:  (define-rule-pattern 
                  name: #f modifiers-pattern: #f pattern: $3)
      template: $6))

  #|
  ((function-rule
     <lcbracket> word <lbracket> opt-pattern <rbracket> <rcbracket>
       <implies> rule-rhs opt-<statement-sep>)
    (function-rule
      name:    $2
      pattern: (function-rule-pattern name: $2 pattern: $4)
      template: $8))
  |#

  ((function-or-local-declaration-rule
     <lcbracket> word opt-pattern <rcbracket>
       <implies> rule-rhs opt-<statement-sep>)
    (function-or-local-declaration-rule
      name:    $2
      pattern: (function-or-local-declaration-rule-pattern name: $2 pattern: $3)
      template: $6))

  ((opt-pattern-variable)
    #f)
  ((opt-pattern-variable pattern-variable)
    $1)

  ((opt-aux-rule-sets)
    '())
  ((opt-aux-rule-sets aux-rule-sets)
    $1)

  ((aux-rule-sets aux-rule-set ...))

  ((aux-rule-set <keyword> aux-rules)
    (aux-rule-set 
       name: (as <symbol> (as <string> $1))
       aux-rules: $2))

  ((aux-rules aux-rule ...))
  
  ((aux-rule 
      <lcbracket> opt-pattern <rcbracket> 
        <implies> rule-rhs opt-<statement-sep>)
    (aux-rule pattern: $2 template: $5))

  ((rule-rhs <lcbracket> opt-template <rcbracket>)
    $2)
  ((rule-rhs expression)
    $1)

  ((opt-macro))
  ((opt-macro :macro))

  ;; -- Patterns

  ((marker-clause "Macro patterns"))

  ((opt-pattern)
    (sequence-fragment fragments: '()))
  ((opt-pattern pattern)
    $1)

  ((pattern the-pattern)
    (sequence-fragment fragments: $1))

  ((opt-the-pattern)
    '())
  ((opt-the-pattern the-pattern)
    $1)

  ((the-pattern pattern-list) 
    $1)
  ((the-pattern pattern-list <statement-sep> opt-the-pattern)
    `(,@$1 ,*semicolon* ,@$3))

  ((opt-pattern-list)
    '())
  ((opt-pattern-list pattern-list)
    $1)

  ((pattern-list pattern-sequence)
    $1)
  ((pattern-list property-list-pattern)
    `(,$1))
  ((pattern-list pattern-sequence <var-sep> pattern-list)
    `(,@$1 ,*comma* ,@$3))

  ((pattern-sequence the-pattern-sequence)
    $1)

  ((the-pattern-sequence simple-pattern ...))

  ((simple-pattern
      pattern-variable)
    $1)
  ((simple-pattern
      pattern-variable <var-type-sep> pattern-variable)
    (variable-pattern name: $1 type: $3))
  ((simple-pattern
      details-pattern)
    $1)
  ((simple-pattern
      literal-pattern)
    $1)
  ((simple-pattern <string> <splice> pattern-variable)
    (spliced-pattern-variable-pattern before: $1 pattern: $3))
  ((simple-pattern pattern-variable <splice> <string>)
    (spliced-pattern-variable-pattern pattern: $1 after: $3))
  ((simple-pattern <string> <splice> pattern-variable <splice> <string>)
    (spliced-pattern-variable-pattern before: $1 pattern: $3 after: $5))

  ((opt-details-pattern)
    #f)
  ((opt-details-pattern details-pattern)
    $1)

  ((details-pattern <lbracket> opt-pattern <rbracket>)
    (bracketed-fragment fragments: (fragments $2)))
  ((details-pattern <lsbracket> opt-pattern <rsbracket>)
    (sbracketed-fragment fragments: (fragments $2)))
  ((details-pattern <lcbracket> opt-pattern <rcbracket>)
    (cbracketed-fragment fragments: (fragments $2)))

  ((pattern-variable <query> word)
     (pattern-variable-pattern name: $2))
  ((pattern-variable <ellipsis>)
     (ellipsis-pattern-variable-pattern))

  ((property-list-pattern 
      :&rest pattern-variable)
     (property-list-pattern rest-pattern: $2 key-patterns: #f))
  ((property-list-pattern 
      :&rest pattern-variable <var-sep> :&key opt-pattern-keywords)
     (property-list-pattern rest-pattern: $2 key-patterns: `(#key ,@$5)))
  ((property-list-pattern 
       :&key opt-pattern-keywords)
     (property-list-pattern rest-pattern: #f key-patterns: `(#key ,@$2)))

  ((opt-pattern-keywords)
    '())
  ((opt-pattern-keywords pattern-keywords)
    $1)

  ((pattern-keywords :&all-keys)
    `(#all-keys))
  ((pattern-keywords pattern-keyword)
    `(,$1))
  ((pattern-keywords pattern-keyword <var-sep> pattern-keywords)
    `(,$1 ,@$3))

  ((pattern-keyword pattern-variable opt-pattern-keyword-default)
    `(,$1 ,@$2))
  ((pattern-keyword sequence-pattern-variable opt-pattern-keyword-default)
    `(,$1 ,@$2))

  ((opt-pattern-keyword-default)
    '())
  ((opt-pattern-keyword-default pattern-keyword-default)
    $1)

  ((pattern-keyword-default <binds> expression)
    `(,$2))
  ((pattern-keyword-default <binds> <lcbracket> opt-template <rcbracket>)
    `(,$3))

  ((sequence-pattern-variable <query-query> word)
    (sequence-pattern-variable-pattern name: $2))

  ((literal-pattern word-fragment)
    $1)
  ((literal-pattern :parsed-name)
    (literal-fragment
       object: $1 token-class: '<symbol> token-value: $1))
  ((literal-pattern :otherwise)
    (literal-fragment
       object: 'otherwise token-class: ':otherwise token-value: $1))
  ((literal-pattern <implies>)
    *implies*)
  ((literal-pattern <escaped-hash-word>)
    $1)
  ((literal-pattern modified-constant)
    $1)

  ((word <symbol>)
    $1)
  ((word <defining-word>)
    $1)
  ((word <fragment-begin-word>)
    $1)
  ((word <fragment-define-word>)
    $1)
  ((word <fragment-define-and-begin-word>)
    $1)
  ((word <fragment-define-bindings-word>)
    $1)
  ((word <fragment-define-bindings-and-begin-word>)
    $1)
  ((word <fragment-function-word>)
    $1)
  ((word <fragment-local-declaration-word>)
    $1)
  ((word <details-begin-word>)
    $1)
  ((word <expr-begin-word>)
    $1)
  ((word <simple-begin-word>)
    $1)
  ((word <details-intermediate-word>)
    $1)
  ((word <expr-intermediate-word>)
    $1)
  ((word <simple-intermediate-word>)
    $1)
  ((word <method-defining-word>)
    $1)
  ((word <generic-function-defining-word>)
    $1)
  ((word <seal-word>)
    $1)

  ((opt-word))
  ((opt-word word))

  ((non-intermediate-word <symbol>)
    $1)
  ((non-intermediate-word <defining-word>)
    $1)
  ((non-intermediate-word <fragment-begin-word>)
    $1)
  ((non-intermediate-word <fragment-define-word>)
    $1)
  ((non-intermediate-word <fragment-define-and-begin-word>)
    $1)
  ((non-intermediate-word <fragment-define-bindings-word>)
    $1)
  ((non-intermediate-word <fragment-define-bindings-and-begin-word>)
    $1)
  ((non-intermediate-word <fragment-function-word>)
    $1)
  ((non-intermediate-word <fragment-local-declaration-word>)
    $1)
  ((non-intermediate-word <details-begin-word>)
    $1)
  ((non-intermediate-word <expr-begin-word>)
    $1)
  ((non-intermediate-word <simple-begin-word>)
    $1)
  ((non-intermediate-word <method-defining-word>)
    $1)
  ((non-intermediate-word <generic-function-defining-word>)
    $1)
  ((non-intermediate-word <macro-defining-word>)
    $1)
  ((non-intermediate-word <seal-word>)
    $1)

  ((opt-non-intermediate-word))
  ((opt-non-intermediate-word non-intermediate-word))

  ;; -- Templates

  ((marker-clause "Macro templates"))

  ((opt-template)
    (template '()))
  ((opt-template template)
    $1)

  ((template replacement)
    (template $1))

  ((opt-replacement)
    '())
  ((opt-replacement replacement)
    $1)

  ((replacement replacement-element ...)
    base: $1
    rec:  `(,@$1 ,@$2))

  ((replacement-element <lbracket> opt-replacement <rbracket>)
    `(<lbracket> ,$1 ,@$2 <rbracket> ,$3))
  ((replacement-element <lsbracket> opt-replacement <rsbracket>)
    `(<lsbracket> ,$1 ,@$2 <rsbracket> ,$3))
  ((replacement-element <lcbracket> opt-replacement <rcbracket>)
    `(<lcbracket> ,$1 ,@$2 <rcbracket> ,$3))
  ((replacement-element <list-open> opt-replacement <rbracket>)
    `(<list-open> ,$1 ,@$2 <rbracket> ,$3))
  ((replacement-element <vector-open> opt-replacement <rsbracket>)
    `(<vector-open> ,$1 ,@$2 <rsbracket> ,$3))
  ((replacement-element <syntax-open> opt-replacement <rcbracket>)
    `(<syntax-open> ,$1 ,@$2 <rcbracket> ,$3))
  #|
  ((replacement-element <query> word)
    `(,(pattern-variable-substitution name: $2)))
  |#
  ((replacement-element <query-query> word separator <ellipsis>)
    `(,(sequence-pattern-variable-pattern name: $2 separator: $3)))
  ((replacement-element <query-query> word <ellipsis>)
    `(,(sequence-pattern-variable-pattern name: $2 separator: #f)))
  ((replacement-element <query-equal> word)
    ;; `(,(escaping-pattern-variable-pattern name: $2))
    `(<symbol>, $2))

  ((replacement-element spliceable-replacement)
    `(,$1))
  ((replacement-element spliceable-replacement <splice> <string>)
    `(,(spliced-pattern-variable-pattern 
	 pattern: $1
         after:   $3)))
  ((replacement-element <string> <splice> spliceable-replacement)
    `(,(spliced-pattern-variable-pattern 
	 before:  $1
	 pattern: $3)))
  ((replacement-element 
      <string> <splice> spliceable-replacement <splice> <string>)
    `(,(spliced-pattern-variable-pattern 
	 before:  $1
	 pattern: $3
         after:   $5)))

  ((spliceable-replacement <query> word)
    (pattern-variable-pattern name: $2))
  ((spliceable-replacement <query> <string>)
    (string-pattern-variable-pattern name: $2))
  ((spliceable-replacement <query> <literal>)
    (symbol-pattern-variable-pattern name: $2))

  #|
  ((replacement-element <query> <string>)
    `(,(string-pattern-variable-pattern name: $2)))
  ((replacement-element <query> <literal>)
    `(,(symbol-pattern-variable-pattern name: $2)))
  |#

  ((replacement-element <query> <lbracket> expression <rbracket>)
    `(,(expression-substitution expression: $3)))
  ((replacement-element 
       <query-query> <lbracket> expression <rbracket> separator <ellipsis>)
    `(,(sequence-expression-substitution expression: $3 separator: $5)))

  ((replacement-element <escaped-substitution>)
    `(,(token-class $1), (token-value $1)))

  ((replacement-element <dot>)
    `(<dot> ,$1))
  ((replacement-element <var-type-sep>)
    `(<var-type-sep> ,$1))
  ((replacement-element <ellipsis>)
    `(,(ellipsis-pattern-variable-pattern)))
  ((replacement-element <implies>)
    `(<implies> ,$1))
  ((replacement-element <keyword>)
    `(<keyword> ,$1))
  ((replacement-element <literal>)
    `(<literal> ,$1))
  ((replacement-element <string>)
    `(<string> ,$1))
  ((replacement-element <unary-operator>)
    `(<unary-operator> ,$1))
  ((replacement-element <not>)
    `(<not> ,$1))
  ((replacement-element :true)
    `(:true ,$1))
  ((replacement-element :false)
    `(:false ,$1))
  ((replacement-element :&next)
    `(:&next ,$1))
  ((replacement-element :&rest)
    `(:&rest ,$1))
  ((replacement-element :&key)
    `(:&key ,$1))
  ((replacement-element :&all-keys)
    `(:&all-keys ,$1))
  ((replacement-element :define)
    `(:define ,$1))
  ((replacement-element :end)
    `(:end ,$1))
  ((replacement-element :generic)
    `(:generic ,$1))
  ((replacement-element :handler)
    `(:handler ,$1))
  ((replacement-element :let)
    `(:let ,$1))
  ((replacement-element :local)
    `(:local ,$1))
  ((replacement-element :method)
    `(:method ,$1))
  ((replacement-element :macro)
    `(:macro ,$1))
  ((replacement-element :otherwise)
    `(:otherwise ,$1))
  ((replacement-element word)
    `(<symbol> ,$1))
  ((replacement-element separator)
    $1)

  #| Case caught by word above.
  ((replacement-element :parsed-name)
    `(:parsed-name ,$1))
  |#
  ((replacement-element :parsed-variable)
    `(:parsed-expression ,$1))
  ((replacement-element :parsed-expression)
    `(:parsed-expression ,$1))
  ((replacement-element :parsed-body)
    `(:parsed-body ,$1))
  ((replacement-element :parsed-case-body)
    `(:parsed-case-body ,$1))
  ((replacement-element :parsed-literal)
    `(:parsed-literal ,$1))
  
  ((separator <statement-sep>)
    `(<statement-sep> ,$1))
  ((separator <var-sep>)
    `(<var-sep> ,$1))
  ((separator <binary-operator>)
    `(<binary-operator> ,$1))
  ((separator <binds>)
    `(<binds> ,$1))
  ((separator <var-singleton-sep>)
    `(<var-singleton-sep> ,$1))
  ((separator <becomes>)
    `(<becomes> ,$1))
  ((separator <minus>)
    `(<minus> ,$1))

  ((marker-clause "Procedural macro extensions"))

  ((marker-clause "Pre-parsed form extensions"))

  ((leaf :parsed-body)
    $1)
  ((leaf :parsed-expression)
    $1)
  ((variable-name :parsed-name)
    $1)
  ((word :parsed-name)
    $1)
  ((modifier :parsed-name)
    $1)
  ((variable-name :parsed-variable)
    (if (instance? $1 <pair>) (first $1) $1))
  ((detail-clause-word :parsed-name)
    $1)

  ((property <var-sep> :parsed-property-list)
    (items $1))
  ((argument :parsed-property-list)
    (items $1))

  ((literal :parsed-literal)
    $1)

  ((constant :parsed-expression)
    $1)

  ((defining-form :parsed-defining-form)
    $1)
  ((local-declaration :parsed-local-declaration)
    $1)
  ((statement :parsed-statement)
    $1)

  ((marker-clause "DylanWorks specific"))


  ((procedural-template
     <syntax-open> opt-template <rcbracket>)
    `(syntax-template ,$2))

  ((operand procedural-template)
    $1)

  ((simple-fragment procedural-template)
    (parsed-fragment 
      token-class: parsed-expression:
      token-value: $1))

  ((defining-form
       :define opt-modifiers <clauses-defining-word> names 
         opt-clause-body
       :end opt-<clauses-defining-word> opt-variable-name)
    `(,(infix-defining-macro-name $3 modifiers: $2) ,$2
         ,$4 
	 (#f ,(first $5))
         ,@(second $5)))

  ((names variable-name)
    $1)
  ((names <lbracket> name-list <rbracket>)
    $2)

  ((name-list variable-name)
    `(,$1))
  ((name-list name-list <var-sep> variable-name)
    `(,@$1 ,$3))

  ((initial-clause-body opt-body intermediate-clause clause-body)
    `((#f ,$1) 
      (,@$2 ,(second (head $3)))
      ,@(tail $3)))

  ((opt-<clauses-defining-word>))
  ((opt-<clauses-defining-word> <clauses-defining-word>))

  ((opt-parameter-list)
    #f)
  ((opt-parameter-list parameter-list)
    $1)

  ((parameter-list <lbracket> opt-parameters <rbracket>)
    $2)

  ;; -- Working definition of a dylan form, used by the top level loop

  ((listener-constituents defining-form)
    `(,$1))
  ((listener-constituents keyless-expression)
    `(,$1))
  ((listener-constituents local-declaration <statement-sep> 
      listener-constituents)
    `(,$1 ,@$3))

  ((command defining-form <statement-sep>)
    $1)
  ((command keyless-expression <statement-sep>)
    $1)
  ((command 
      local-declaration <statement-sep> listener-constituents <statement-sep>)
    (rewrite-parsed-body `(,$1 ,@$3)))
  ((command <keyword> <statement-sep>)
    $1)
  ((command <keyword> constituent <statement-sep>)
    `(,$1 ,$2))
  #|
  ((command :eoi)
    $1)
  |#

  ;; Constraint parsing

  ((command :expression-constraint expression :end)
    $2)
  ((command :variable-constraint variable :end)
    $2)
  ((command :name-constraint word :end)
    $2)
  ((command :body-constraint opt-body :end)
    $2)
  ((command :case-body-constraint opt-case-body :end)
    $2)
  ((command :macro-constraint expression :end)
    (expanded-constraint $2))
  ((command :macro-constraint defining-form :end)
    (expanded-constraint $2))
  ((command :fragment-constraint opt-fragment :end)
    $2)

)

;; eof
