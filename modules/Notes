Implementation Notes.

For syntax, cos modules themselves are pretty straight forward. The
idea's this. An "expression" form is expanded into a runtime form
including the name of the target module. The restrictions on this
aren't known at the moment (can macro expansions reference unexported
bindings?).

We add an extra header option "expression-module" to name the module
within which generated code in the body of the file is to be
evaluated. This defaults to the module the macro code lives in. 

Why? Because, for example, the code generated by compiler rewrites
shouldn't be evaluated in the compiler module, which won't exist at
run time. More likely, we want code the compiler generates to be
evaluated in the dylan module or some module based on dylan but
extended by internal system forms.

Note that this extends to the left hand side of destructuring code
within macros too. 

  module:            compiler
  expression-module: dylan

  (define-method ...
    (expression-case form
      ((? bob ?name ...) ...)))

In the form, bob must be the one from the dylan module to match. 

