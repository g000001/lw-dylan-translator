;; -*- rcs-header: "$Header: /scm/cvs/fundev/old/Sources/emulator/parsergen/newnewderiv.lisp,v 1.1 2004/03/12 00:41:16 cgay Exp $" -*-

;; #<harlequin copyright marker>

(in-package "PARSERGEN")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; newderiv.lisp
;;;
;;; MLA 3/9/90
;;;
;;; Updated 6/9/90 to include A |-> A@ items
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Contains functions for precomputing values used in the generation
;;; of parsing tables from kernels of item sets.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; The aim is to calculate, for every non-terminal A, the set of
;;; pairs of non-terminal B and terminal a, such that there is a
;;; right-most derivation A => Bax, for some string x.  The empty
;;; string @ is considered a terminal, and A => B@x just when x is
;;; empty and A => B.
;;;
;;; In the following, we shall write A |-> Ba for "There exists a
;;; rightmost derivation A => Bax for some x" and A |-> B@ for "There
;;; exists a rightmost derivation A => B"
;;;
;;; The rules used to construct the relation |-> are as follows:
;;;
;;; Rule 0:
;;; For every non-terminal A, A |-> A@.
;;;
;;; Rule 1:
;;; For every production A -> Bx, if a is in first(x) then A |-> Ba.
;;; This is also true for a = @.
;;;
;;; Rule 2:
;;; For every production A -> Bx, if B |-> Ca, with a not @, then A |-> Ca
;;; and if B |-> C@, then A |-> Ca, for every a in first(x)
;;;
;;;
;;; The relation |-> is then defined by the closure of the three rules
;;; above (proof left to reader).
;;;
;;; In fact, the pairs in the relation generated by rule 1 are also
;;; generated by the combination of rules 0 and 2.  Therefore, Rule 1
;;; need not feature in the algorithm.
;;;
;;; The algorithm is as follows:
;;; Generate the initial pairs in the relation by Rule 0.
;;; Construct a set of "propagation rules" according to rule 2.
;;; Apply the propagation rules to the pairs in the relations, adding
;;; new pairs, until no more new pairs can be added.
;;;
;;; The main functions are:
;;; (make-initial-item-set) returns the set of initial values
;;; for |-> as defined by Rule 1.  Each triple A |-> Ba is represented
;;; as a structure defining A, B and a.
;;;
;;; (make-deriv-rule-set grammar) returns the set of propagation rules
;;; for grammar, as defined by Rule 2 above.  Each rule is represented
;;; by a structure containing the non-terminal that is being
;;; propagated from, the non-terminal that is being propagated to, and
;;; the associated list of terminals, (ie. A, B and first(x) in
;;; above).
;;; The set of rules is returned as a hash-table, indexed by
;;; non-terminals, each non-terminal being associated with the list of
;;; the propagation rules from that non-terminal.
;;;
;;; (propagate-derivs rules items) applies the rules to the items to
;;; close the relation, returning the result in a hash-table,
;;; associating each non-terminal A with the list of lists (B a) such
;;; that A |-> Ba.  The parameter rules is a set of rules, format as
;;; returned by make-deriv-rule-set, the parameter rules is a list of
;;; triples as returned by
;;; make-initial-item-set.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defvar *deriv-table*)

(defun setup-derivs (grammar)
  (setq *deriv-table* (make-nt-first-set grammar)))

(defun derivs-of (nt)
  (gethash nt *deriv-table*))

(defun make-nt-first-set (grammar)
  (propagate-derivs (make-deriv-rule-set grammar)
		    (make-initial-item-set)))

(defun make-initial-item-set ()
  (mapcar #'(lambda (non-t) (make-deriv-item :initial non-t
					     :result non-t
					     :terminal nil))
	  (non-terminals)))

(defun make-deriv-rule-set (grammar)
  (let ((rule-set (make-hash-table)))
    (dolist (production grammar rule-set)
     (let* ((rhs (production-rhs production))
	    (lhs (production-lhs production)))
       (when (and (not (null rhs))
		  (is-non-terminal (first rhs)))
	     (add-rule-to-set
	      (make-deriv-rule :from (first rhs)
			       :to lhs
			       :terminals (get-first-set-string (rest rhs)))
			      (first rhs)
			      rule-set))))))

(defun propagate-derivs (rule-set items)
  (let((result (make-item-set)))

    ;;; result contains all the items that have been in items list.
    ;;; Initialize by adding all the initial items in items.
    (dolist (item items)
	    (unless (item-is-in-set item result)
		    (add-item-to-set item result)))

    ;;; Now do the propagation by removing items from items, applying
    ;;; the rules, and adding the new items to items, as well as
    ;;; storing them in result.
    (loop
     (if (null items)
	 (return result))
     (let ((item (pop items)))
       (dolist (new-item (apply-rules rule-set item))
	       (unless (item-is-in-set new-item result)
		       (add-item-to-set new-item result)
		       (push new-item items)))))))

;;; (apply-rules rule-set item) applies all the rules in rule-set to
;;; the item, returning a list of the new items generated by the
;;; rules.  The returned list may contain duplicates.

(defun apply-rules (rule-set item)
  (let((relevant-rules (get-rules-for (deriv-item-initial item) rule-set))
       (result nil))
    (dolist (rule relevant-rules)
	    (if (null (deriv-item-terminal item))
		(dolist (term (deriv-rule-terminals rule))
			(push (make-deriv-item :initial (deriv-rule-to rule)
					       :result (deriv-item-result item)
					       :terminal term)
			      result))
	      (push (make-deriv-item :initial (deriv-rule-to rule)
				     :result (deriv-item-result item)
				     :terminal (deriv-item-terminal
						item))
		    result)))
    result))

;;; Access functions for sets of rules

(defun add-rule-to-set (rule symbol set)
  (push rule (gethash symbol set)))

(defun get-rules-for (symbol rule-set)
  (gethash symbol rule-set))

;;; Access functions for productions

(defun production-rhs (production)
  (cdr production))

(defun production-lhs (production)
  (car production))

;;; Access functions for sets of items, represented by hash tables.

(defun make-item-set ()
  (make-hash-table))

(defun item-is-in-set (item set)
  (member (deriv-item-terminal item)
	  (cdr (assoc (deriv-item-result item)
		 (gethash (deriv-item-initial item) set)))))

(defun add-item-to-set (item set)
  (let* ((initial (deriv-item-initial item))
	 (result (deriv-item-result item))
	 (terminal (deriv-item-terminal item))
	 (current-result (gethash initial set))
	 (result-assoc (assoc result current-result)))
    (unless (member terminal
		    (cdr result-assoc))
	    (if result-assoc
		(push terminal
		      (cdr result-assoc))
	      (push (list result terminal)
		    (gethash initial set))))))


;;; Structure definitions for items and rules

(defstruct (deriv-item (:type list))
  initial   ;;; A
  result    ;;; B
  terminal) ;;; a

(defstruct deriv-rule 
  from       ;;; propagate from here
  to         ;;; to here
  terminals) ;;; using these terminals
